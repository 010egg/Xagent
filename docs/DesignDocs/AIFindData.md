AI找数系统升级
系统升级的核心目标是帮助业务用户“找表”实现又快又准，其本质是一个信息检索 + 判定系统，而非生成系统。
一、背景与目标：系统演进路径

表 1: V1 与 V2 版本功能对比与演进目标
版本	核心策略	关键能力	演进目标
V1	基于数仓分层的关键词检索策略和重排	初步的分词和业务词汇抽取；纯表描述的向量匹配	基础关键词检索与分层重排
V2	拓展基于业务领域的划分，深化分层检索策略和重排建设	基于 BM25 和倒排 的检索深化；多路权重 融合	期望能够按照业务领域（效果、花火、品牌、DMP、Bdata、游戏、带货等）迅速拓展，实现领域化、深化分层检索。
二、痛点分析：当前“慢且不准”的原因

AI 帮助业务“找表”的有效性，依赖于约束搜索空间 + 语义对齐 + 可验证闭环。当前系统“慢且不准”的原因（反直觉诊断）主要集中在以下四个方面：
1.搜索空间失控： AI 在 ODS/DWD/DWS/ADS 全库游走，导致搜索空间过大，本身就是指数级噪声。
2.业务语义未结构化： 业务语言（如“消耗 / GMV / 曝光”）与底层字段（cost_amt / order_amount / imp_cnt）存在语义鸿沟，模型只能进行猜测。
3.表 ≠ 指标： 业务用户寻找的是可用口径，但系统仅提供表名，无法满足实际需求。
4.无失败反馈： 选错后缺乏负反馈机制，导致模型无法从错误中学习，无法形成可验证闭环。
三、真正有效的总体架构（高密度版）

有效的架构设计将“找表”过程拆解为三个子问题，并引入关键的工程约束和判定机制。
3.1 “找表”拆解为 3 个子问题

子问题	核心目标	AI 角色
1. 找主题域	缩小 90% 搜索空间	分类器
2. 找候选资产	Recall ≥ 95%	检索器
3. 判可用性	Precision ≥ 80%	判定器
3.2 提升“快”的关键：工程约束

核心在于强制分层裁剪，将“全库搜索”降维成“业务视角搜索”，而非依赖更大的模型。
●强制分层裁剪（最关键）：默认只推荐 DWS/ADS 层资产。
○允许 DWD 作为“构建路径/候补源”。
○允许 ODS 作为“溯源证据/救急”。
○输出必须携带风险标签（例如：“口径需确认/可能不完整/需补模”）。
3.3 元数据向量化：Asset Card 特征

元数据向量化应聚焦于 Asset Card 特征，而非简单的表名向量化。Asset Card 应包含以下四类特征集合：
特征类型	关键特征（可落库的特征集合）
语义特征	主题域、指标别名词典、业务对象（UP/广告主/订单）、粒度（实体键）、时间语义（事件类型：曝光/点击/下单/完成）
治理特征	负责人、SLA、延迟分位、质量规则通过率、血缘完整度、是否推荐/是否弃用
使用特征	下游看板数、查询频次、近 30 天活跃度、被否决次数（按意图聚合）
风险特征	口径争议、临时表、历史回填、字段变更频率、分区缺失率
3.4 可用性判定：四段式 Gate 机制

判定器通过四段式 Gate 机制，确保资产的可用性（Precision ≥ 80%）。
阶段	Gate 名称	判定类型	核心校验内容
1	Schema Gate	静态	粒度键是否齐备（可 group by）；事件时间字段类型/分区字段一致性。
2	Query Gate	可运行	自动生成最小 SQL（limit 采样、分区强制）并执行。
3	Shape Gate	形态	输出行数/空值率/去重后基数是否合理（例如按 UP 聚合后行数 ≈ UP 数量级）。
4	Invariant Gate	不变量/对账	与“已知基准”对比（历史看板同口径、或权威指标表）；或做弱不变量：单调性、范围、比例（CTR ≤ 1、消耗 ≥ 0 等）。
3.5 负反馈机制

负反馈必须携带上下文，以避免将“历史误判”固化为系统偏见。
●负反馈上下文： {意图、主题域、用户/团队、时间、否决原因、有效期}
●否决原因示例： 场景不匹配（对该意图不适用）、数据延迟（当时不可用）、权限不可见（对某团队不可用）。
四、产品化输出契约：Metric Contract

系统最终输出应为结构化的 Metric Contract（指标契约），确保指标的定义、来源、验证和责任可追溯。
契约字段	描述
metric_name	指标的唯一名称。
definition	指标的口径定义（口径/过滤/去重/时间窗）。
grain	指标的粒度键。
time_event	业务时间字段 + 事件类型。
source_assets	主/备资产，需携带版本与风险标签。
runnable_sql	最小可运行 SQL + 生产版 SQL。
validations	通过了哪些 Gate 验证。
owner	负责人。
SLA	服务等级协议。
last_verified_at	最近一次验证时间。
五、“准”的关键：把 SQL 当成“可验证的程序”
查询契约 Query Contract（先于 SQL）
在生成 SQL 之前强制输出并锁定：
●指标/度量：metric（消耗/GMV/曝光…）
●维度：dims（按天/按UP/按广告主…）
●粒度键：grain_keys
●时间语义：time_field + event_type + timezone
●过滤：filters（状态、去重、口径约束）
●数据源优先级：primary_asset / fallback_asset
●风险声明：assumptions（缺失口径则明确）
●如果逻辑复杂或者不清晰可以主动和用户讨论业务逻辑举正反例（可选）
没有契约就没有“对错”的判定标准。没有完成澄清前持续进行human_in_the_loop（至少1次）
生成策略：别让模型“从零写 SQL”，让它“填空”
A. SQL Skeleton / Template（按意图族）
常见意图族（每族一套骨架）：
●聚合报表（metric by dims by time）
●漏斗/转化
●留存/分群
●排名/TopN
●明细拉取（带分页/采样）
●对比（A/B、分组差异）
模型只负责：
●选择骨架
●填充表/字段/过滤条件
●选择 join 路径（在候选图内）
模板化会显著提升稳定性与可控性。
B. Schema Linking 用“证据”，不是“猜”
每个字段映射必须附带证据：
●命中别名词典
●注释匹配
●历史 SQL 复用
●下游使用频次/看板绑定
 证据弱则降级：提示需确认口径/给备选映射。
自愈与负反馈：让系统“越用越准”
负反馈必须结构化：
{意图, 资产, 字段映射, 时间, 团队, 失败类型(口径/延迟/权限/性能/歧义), 有效期}
 否则你会把“暂时不可用”误学成“永远不可用”。